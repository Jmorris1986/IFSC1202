#!/usr/bin/env python3
"""
malware_defense_ping.py

A safe, defensive network liveness checker for monitoring hosts.

Features:
- Uses the system `ping` command on Unix-like systems for ICMP-based checks.
- Falls back to a TCP connect check if ICMP is unavailable or if chosen via --method tcp.
- Async/concurrent checks with a concurrency limit.
- Writes a timestamped log file and prints a summary.

Security and usage notes:
- This tool is intended for legitimate network monitoring and incident response.
- Do not use it to scan networks you do not own or have permission to monitor.

"""

import argparse
import asyncio
import sys
import platform
import shlex
from datetime import datetime
from pathlib import Path

DEFAULT_LOG = "malware_defense_ping.log"


async def ping_with_system(host: str, timeout: int = 2, count: int = 1) -> bool:
    """Use the system `ping` command (works on Linux/macOS). Returns True if host replies."""
    # Build platform-appropriate ping command
    system = platform.system()
    if system == "Windows":
        # Windows ping flags: -n count, -w timeout_ms
        cmd = ["ping", "-n", str(count), "-w", str(timeout * 1000), host]
    else:
        # Unix-like: -c count, -W timeout_seconds (Note: some versions use -W differently)
        cmd = ["ping", "-c", str(count), "-W", str(timeout), host]

    try:
        proc = await asyncio.create_subprocess_exec(
            *cmd,
            stdout=asyncio.subprocess.DEVNULL,
            stderr=asyncio.subprocess.DEVNULL,
        )
        returncode = await proc.wait()
        return returncode == 0
    except FileNotFoundError:
        # ping command not available
        return False
    except Exception:
        return False


async def tcp_connect(host: str, port: int = 80, timeout: int = 2) -> bool:
    """Attempt a TCP connection to host:port. Returns True on success."""
    try:
        fut = asyncio.open_connection(host, port)
        reader, writer = await asyncio.wait_for(fut, timeout=timeout)
        writer.close()
        try:
            await writer.wait_closed()
        except Exception:
            pass
        return True
    except Exception:
        return False


async def check_host(host: str, method: str, timeout: int, port: int) -> (str, bool):
    host = host.strip()
    if not host:
        return host, False

    if method == "auto":
        # Prefer system ping; if not available, fall back to TCP
        ok = await ping_with_system(host, timeout)
        if ok:
            return host, True
        else:
            # try tcp on common ports
            return host, await tcp_connect(host, port=port, timeout=timeout)
    elif method == "ping":
        return host, await ping_with_system(host, timeout)
    elif method == "tcp":
        return host, await tcp_connect(host, port=port, timeout=timeout)
    else:
        return host, False


async def run_checks(hosts, concurrency: int, method: str, timeout: int, port: int, log_path: Path):
    sem = asyncio.Semaphore(concurrency)

    async def worker(h):
        async with sem:
            start = datetime.utcnow().isoformat()
            ok = await check_host(h, method, timeout, port)
            ts = datetime.utcnow().isoformat()
            return h, ok[1] if isinstance(ok, tuple) else ok, start, ts

    tasks = [asyncio.create_task(worker(h)) for h in hosts]
    results = []
    for t in asyncio.as_completed(tasks):
        try:
            res = await t
        except Exception:
            continue
        results.append(res)
        host, alive, start, end = res
        line = f"{end} | {host} | {'UP' if alive else 'DOWN'}"
        print(line)
        log_path.write_text(line + "\n", encoding="utf-8", append=False) if False else None

    # Write a combined log append
    with log_path.open("a", encoding="utf-8") as f:
        for host, alive, start, end in results:
            f.write(f"{end} | {host} | {'UP' if alive else 'DOWN'}\n")

    return results


def read_targets_from_file(path: Path):
    if not path.exists():
        raise FileNotFoundError(f"Targets file {path} not found")
    with path.open("r", encoding="utf-8") as f:
        return [line.strip() for line in f if line.strip() and not line.strip().startswith("#")]


def parse_args():
    p = argparse.ArgumentParser(description="Simple defensive liveness checker (ping/tcp) for approved networks")
    p.add_argument("--targets-file", "-f", type=Path, help="Path to newline-separated targets file (hosts or IPs)")
    p.add_argument("--hosts", "-H", nargs="*", help="One or more hosts to check directly")
    p.add_argument("--concurrency", "-c", type=int, default=20, help="Maximum concurrent checks")
    p.add_argument("--timeout", "-t", type=int, default=2, help="Timeout in seconds per check")
    p.add_argument("--method", choices=["auto", "ping", "tcp"], default="auto", help="Check method: auto/ping/tcp")
    p.add_argument("--port", type=int, default=80, help="Port to use for TCP checks (when method=tcp or auto fallback)")
    p.add_argument("--log", type=Path, default=Path(DEFAULT_LOG), help="Path to append log lines")
    return p.parse_args()


def main():
    args = parse_args()
    hosts = []
    if args.targets_file:
        hosts.extend(read_targets_from_file(args.targets_file))
    if args.hosts:
        hosts.extend(args.hosts)

    if not hosts:
        print("No hosts provided. Use --targets-file or --hosts.")
        sys.exit(2)

    # Ensure log file exists
    args.log.parent.mkdir(parents=True, exist_ok=True)
    header = f"\n--- Run at {datetime.utcnow().isoformat()} Method={args.method} Concurrency={args.concurrency} Timeout={args.timeout}s Port={args.port} ---\n"
    with args.log.open("a", encoding="utf-8") as f:
        f.write(header)

    try:
        results = asyncio.run(run_checks(hosts, args.concurrency, args.method, args.timeout, args.port, args.log))
    except KeyboardInterrupt:
        print("Interrupted")
        sys.exit(1)

    up = sum(1 for _, alive, *_ in results if alive)
    down = len(results) - up
    print(f"Summary: {len(results)} checked, {up} UP, {down} DOWN. Log: {args.log}")


if __name__ == "__main__":
    main()
